;; TODO check malformed macro

(define (try-expand-macro stack expr)
  (cond ((and (pair? expr) (lookup-env (env-stack stack) (car expr)))
         => (lambda (obj)
              (if (obj-macro? obj)
                (let ((result (expand-macro (cdr obj) (cdr expr))))
                  ;(print expr)
                  (if (eq? result 'error-no-pattern)
                    (goto-error stack "macro pattern doesn't match")
                    result))
                #f)))
        (else #f)))

(define (expand-macro macro body)
  (let ((env (car macro))
        (literals (cadr macro))
        (rules (caddr macro)))
    (define (find-match rules)
      (if (null? rules)
        #f
        (let ((matched (match-pattern literals (car rules) body)))
          (if matched
            (cons matched (cadr rules))
            (find-match (cddr rules))))))
    (let ((found (find-match rules)))
      (if found
        (inflate-template env (car found) (cdr found))
        'error-no-pattern))))

(define (match-pattern literals pattern body)
  (call/cc
    (lambda (cc)
      (define (recur-match pattern body)
        (cond ((and (null? pattern) (null? body))
                (list '()))
              ((and (pair? pattern) (pair? body))
                (if (and (pair? (cdr pattern)) (eq? (cadr pattern) '...))
                  (if (list? body)
                    (cons '()
                          (map (lambda pairs (caar pairs (map cdr pairs)))
                               . (map recur-match (car pattern) body)))
                    (cc #f))
                  (let ((res-car (recur-match (car pattern) (car body)))
                        (res-cdr (recur-match (cdr pattern) (cdr body))))
                    (map append res-car res-cdr))))
              ((and (vector? pattern) (vector? body))
                (recur-match (vector->list pattern) (vector->list body)))
              ((symbol? pattern)
                (if (memq pattern literals)
                  (if (eq? body pattern)
                    (list '())
                    (cc #f))
                  (list (list (cons pattern body)))))
              (else (cc #f))))
      (recur-match (cdr pattern) body))))

(define (inflate-template env binds template)
  (call/cc
    (lambda (cc))
      (define slice-sub-binds
        (unfold (lambda dict
                  (cond ((every null? dict) #t)
                        ((not (any null?)) #f)
                        (else (cc (obj-error "f*ck")))))
                (lambda dict (map (lambda pair (cons (car pair) (cadr pair)) dict)))
                (lambda dict (map (lambda pair (cons (car pair) (cddr pair)))))
                binds))
      (define (recur-inflate template)
        (cond ((null? template) (list '()))
              ((pair? template)
                (if (and (pair? (cdr template)) (eq? (cadr template) '...))
                  (let ((inflate-one
                          (lambda (sub-binds) (inflate-template env sub-binds (car template)))))
                    (filter (lambda (res) (car res)) (map inflate-one subbinds)))
                          (car (recur-inflate (cdr template))))
               (let* ((pair-car (recur-inflate (car template)))
                      (res-car (car pair-car))
                      (syms-car (cdr pair-car))
                      (res-cdr
                        (if (and (pair? (cdr template)) (eq? (cadr template) '...))
                          (let* ((sub-binds (filter (lambda (bind) (memq (car bind) syms-car))))
                                 (sliced-sub-binds (slice-sub-binds sub-binds)))
                            (map (lambda (binds) (inflate-template env binds (car template)))
                                 sliced-sub-binds))
                          (car (recur-inflate (cdr template))))))
                 (cons (cons res-car res-cdr) syms-car)))
              ((vector? template)
                (list->vector (recur-inflate (vector->list template))))
              ((and (symbol? template) (assq template (car binds)))
                => (lambda (pair) (list (cdr pair) (car pair))))
              ((and (symbol? template) (not (memq template keywords)))
                (list (hold-env template env)))
              (else (list template))))
      (car (recur-inflate template))))
